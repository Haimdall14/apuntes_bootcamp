<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/assets/css/style.css">
    <style>ul {list-style-image: url(/assets/img/ico/rubycolor.svg);}</style>
    <title>Resumen {Codeable}</title>
  </head>
  <body>
    <header class="header">
      <div class="container1024">
        <nav class="navbar">
          <input type="checkbox" id="menu-mobile">
            
          <a href="#" class="navbar__logo text-decoration-none">
            <span class="logo">Notes</span>
  
            <label for="menu-mobile" id="menu-close">
              <i class="ri-close-fill ri-sm navbar__logo" style="font-size: 20px; color: white;"></i>
            </label>
  
            <label for="menu-mobile" id="menu-open">
              <i class="ri-menu-fill ri-sm navbar__logo" style="font-size: 20px; color: white;"></i>
            </label>
            
          </a>
          <ul class="expandable navbar__links list-style-none link">
            <li><a href="index.html"> <img src="/assets/img/ico/setting.svg" alt="icono config" height="20px"> Config</a></li>
            <li><a href="ruby.html"> <img src="/assets/img/ico/ruby.svg" alt="icono ruby" height="20px"> Ruby</a></li>
            <li><a href="html_css.html"> <img src="/assets/img/ico/html_css.svg" alt="icono html" height="20px"> HTML & CSS</a></li>
            <li><a href="rails.html"> <img src="/assets/img/ico/rails.svg" alt="icono rails" height="21px"> Rails</a></li>
            <li><a href="js.html"> <img src="/assets/img/ico/js.svg" alt="icono JS" height="20px"> JavaScript</a></li>
            <li><a href="react.html"> <img src="/assets/img/ico/react.svg" alt="icono react" height="20px"> React</a></li>            
          </ul>
        </nav>
      </div>
    </header>

    <main>
      <section class="container-major">
        <article>
          <h1 class="title"><img src="assets/img/ico/rubycolor.svg" alt="config" height="27"> Ruby</h1>
          <div>
            <p>Antes de iniciar recomendamos visitar los siguientes links para consultas futuras:</p>
          <ul>
            <li>
              <a href="https://ruby-doc.org/" target="_blank">Ruby Documentation</a>
            </li>
            <li>
              <a href="https://www.codecademy.com/courses/learn-ruby/lessons/introduction-to-ruby/exercises/data-types-numbers-strings-booleans" target="_blank">Ruby by Codecademy</a>
            </li>
            <li>
              <a href="http://ruby-for-beginners.rubymonstas.org/index.html" target="_blank">Ruby for Beginners by Ruby Monstas</a>
            </li>
            <li>
              <a href="https://rubystyle.guide/" target="_blank">Ruby Style Guide</a>
            </li>
          </ul>
          
          <details>
            <summary class="sub manito">Ruby Basic 1</summary>

              <details>
                <summary class="subin manito">Resumen</summary>
                <p>Ruby es un lenguaje de programación de alto nivel, dinámico y orientado a objetos. Fue desarrollado por Yukihiro "Matz" Matsumoto en Japón a mediados de los 90. Ruby se destaca por su sintaxis clara y expresiva, y su enfoque en la programación fácil y agradable.</p>
                <p>En Ruby, todo es un objeto, lo que significa que cada valor y función se representa como un objeto en tiempo de ejecución. Ruby cuenta con una gran cantidad de características y bibliotecas estándar que lo hacen adecuado para una amplia variedad de aplicaciones, desde la creación de scripts hasta el desarrollo web y de aplicaciones móviles.</p>
                <p>Algunas de las características notables de Ruby incluyen:</p>
                <ul>
                  <li>Una sintaxis fácil de leer y escribir que favorece la legibilidad y la simplicidad.</li>
                  <li>Un sistema de tipos dinámicos que permite una gran flexibilidad en la escritura de código.</li>
                  <li>Soporte integrado para programación orientada a objetos, incluyendo clases, objetos, métodos y herencia.</li>
                  <li>Un recolector de basura automático que administra automáticamente la memoria utilizada por el programa.</li>
                  <li>Bibliotecas estándar ricas que cubren una amplia variedad de áreas, desde programación de redes hasta procesamiento de texto.</li>
                </ul>
                <p>En resumen, Ruby es un lenguaje de programación poderoso y expresivo que se enfoca en hacer la programación fácil y agradable, lo que lo convierte en una opción popular para una amplia variedad de aplicaciones.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Datos (Concepto, Tipos)</summary>
                <p>En Ruby, un dato es un valor que puede ser almacenado y manipulado en un programa. Los datos en Ruby pueden ser de diferentes tipos, como números, cadenas de texto, booleanos, arreglos, hashes, símbolos, expresiones regulares, rangos, nulos, entre otros.</p>
                <p>Cada tipo de dato en Ruby tiene su propio conjunto de métodos y operaciones que se pueden utilizar para manipular y trabajar con ellos. Los datos se pueden asignar a variables para que puedan ser reutilizados en diferentes partes del programa, y también se pueden pasar como argumentos a métodos y funciones.</p>
                <p>El concepto de datos es fundamental en la programación en Ruby, ya que cualquier programa que se escriba necesitará trabajar con algún tipo de dato en algún momento. Por lo tanto, es importante tener una comprensión clara de los diferentes tipos de datos disponibles en Ruby y cómo se pueden manipular para lograr los objetivos del programa.</p>
                <p>En Ruby, existen varios tipos de datos, algunos de ellos son:</p>
                <ol>
                  <li><span class="sres">Números enteros (Integer):</span> se pueden representar como valores positivos o negativos sin fracciones.<br>Ejemplo: 1, 2, 3, -1, -2, -3, etc.</li><br>
                  <li><span class="sres">Números flotantes (Float):</span> representan números reales con decimales.<br>Ejemplo: 1.23, 2.45, 3.14159, etc.</li><br>
                  <li><span class="sres">Cadenas de texto (String):</span> una cadena de caracteres que se utiliza para representar texto.<br>Ejemplo: "Hola", "Mundo", "¡Hola, Mundo!", etc.</li><br>
                  <li><span class="sres">Booleanos (Boolean):</span> un valor booleano puede ser verdadero (true) o falso (false).<br>Ejemplo: true, false.</li><br>
                  <li><span class="sres">Arreglos (Array):</span> un arreglo es una colección ordenada de elementos, que pueden ser de cualquier tipo.<br>Ejemplo: [1, 2, 3], ["hola", "mundo"], etc.</li><br>
                  <li><span class="sres">Hashes (Hash):</span> un hash es una colección de pares clave-valor, donde la clave se utiliza para acceder al valor.<br>Ejemplo: { "nombre" => "Juan", "edad" => 30 }, etc.</li><br>
                  <li><span class="sres">Símbolos (Symbol):</span> un símbolo es una cadena de texto que se utiliza como identificador en lugar de una cadena de texto completa.<br>Ejemplo: :nombre, :edad, etc.</li><br>
                  <li><span class="sres">Expresiones regulares (Regexp):</span> una expresión regular es una secuencia de caracteres que forman un patrón de búsqueda.<br>Ejemplo: /hola/, /[0-9]+/, etc.</li><br>
                  <li><span class="sres">Rangos (Range):</span> un rango representa un conjunto de valores que se encuentran entre un valor inicial y un valor final.<br>Ejemplo: 1..10, 'a'..'z', etc.</li><br>
                  <li><span class="sres">Nulos (NilClass):</span> representa la ausencia de un valor.<br>Ejemplo: nil.</li>
                </ol>
                <p>Estos son algunos de los tipos de datos en Ruby, aunque hay otros tipos de datos más complejos y especializados que se pueden utilizar en programación.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Imprimir (puts y print)</summary>
                <p>En Ruby, tanto "print" como "puts" se utilizan para imprimir salida en la consola o terminal. Ambos métodos pueden imprimir cadenas de caracteres y objetos.</p>
                <p>La diferencia entre "print" y "puts":</p>
                <ul>
                  <li>"puts" agrega automáticamente un salto de línea al final de la salida impresa,</li>
                  <li>"print" imprimirá en la misma línea varios print (sin salto de línea).</li>
                </ul>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Concatenar / Interpolar</summary>
                <p>En Ruby, concatenar y interpolar son dos formas diferentes de combinar cadenas de caracteres.</p>
                <p><span class="sres"><b>• Concatenar</b></span> se refiere a la unión de dos o más cadenas de caracteres en una sola cadena. En Ruby, se utiliza el operador de concatenación + para unir dos cadenas de caracteres. Por ejemplo:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 350px;">
                    <img src="/assets/img/ruby/rb1/concat.png" alt="ruby concat">
                  </div>
                </div>
                <p>Como se puede ver en el ejemplo, el operador + se utiliza para concatenar las variables nombre y apellido con un espacio en blanco en el medio.</p>
                
                <p><span class="sres"><b>• Interpolar</b></span> se refiere a la inclusión de valores de variables en una cadena de caracteres. En Ruby, se utiliza el signo de almohadilla # seguido de llaves { } para interpolar una variable en una cadena de caracteres. Por ejemplo:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 350px;">
                    <img src="/assets/img/ruby/rb1/interpola.png" alt="ruby interpolar">
                  </div>
                </div>
                <p>En este caso, en lugar de utilizar el operador + para concatenar las variables nombre y apellido, se utiliza la interpolación para incluir el valor de las variables en la cadena de caracteres utilizando las llaves { } y el signo de almohadilla #.</p>
                <p>En resumen, la principal diferencia entre concatenar e interpolar en Ruby es que la concatenación une dos o más cadenas de caracteres en una sola, mientras que la interpolación permite incluir el valor de una variable en una cadena de caracteres.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Comentar en el código</summary>
                <p>En Ruby, se pueden utilizar dos tipos de comentarios para agregar notas y explicaciones al código sin que afecten su ejecución: comentarios de una sola línea y comentarios de varias líneas.</p>
                <p>Los comentarios de una sola línea comienzan con el símbolo # y se extienden hasta el final de la línea. Por ejemplo:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 450px;">
                    <img src="/assets/img/ruby/rb1/coment_line.png" alt="comentar">
                  </div>
                </div>
                <p>Los comentarios de varias líneas se encierran entre =begin y =end. Por ejemplo:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 160px;">
                    <img src="/assets/img/ruby/rb1/coment_block.png" alt="comentario">
                  </div>
                </div>
                <p>Estos son los usos más comunes de los comentarios en Ruby:</p>
                <ul>
                  <li>Documentación: se pueden agregar comentarios para documentar el código y explicar su funcionalidad.</li>
                  <li>Depuración: se pueden agregar comentarios para deshabilitar temporalmente secciones de código o para agregar notas de depuración.</li>
                  <li>Explicación: se pueden agregar comentarios para explicar la intención detrás del código, el propósito de las variables o las decisiones de diseño.</li>
                </ul>
                <p>Es importante recordar que los comentarios no afectan la ejecución del código y solo son visibles para los desarrolladores que leen el código fuente. Los comentarios deben utilizarse de manera efectiva para hacer el código más legible y fácil de entender para los desarrolladores que lo mantienen y mejoran con el tiempo.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Operadores Matemáticos</summary>
                <p>En programación, los operadores matemáticos son símbolos que se utilizan para realizar operaciones matemáticas básicas, como la suma, la resta, la multiplicación, la división, la potencia, el módulo, entre otras.</p>
                <p>Los operadores matemáticos se utilizan para realizar cálculos en expresiones matemáticas en un programa de computadora. En la mayoría de los lenguajes de programación, como Ruby, los operadores matemáticos siguen las mismas reglas que las operaciones matemáticas normales. Por ejemplo, en una expresión matemática 2 + 3 * 4, primero se realizaría la operación de multiplicación (3 * 4) y luego se sumaría el resultado con 2.</p>
                <p>Los operadores matemáticos son una herramienta fundamental en la programación y se utilizan para realizar todo tipo de cálculos matemáticos. Además de los operadores matemáticos básicos, como la suma, la resta, la multiplicación y la división, los lenguajes de programación modernos también proporcionan operadores matemáticos más avanzados, como la potencia, el módulo, los operadores de comparación, entre otros.</p>
                <p>En Ruby, los operadores matemáticos básicos son:</p>
                <ol>
                  <li><span class="sres">Suma (+):</span> se utiliza para sumar dos valores.<br>Ejemplo: 2 + 3</li><br>
                  <li><span class="sres">Resta (-):</span> se utiliza para restar un valor de otro.<br>Ejemplo: 5 - 3</li><br>
                  <li><span class="sres">Multiplicación (*):</span> se utiliza para multiplicar dos valores.<br>Ejemplo: 2 * 3</li><br>
                  <li><span class="sres">División (/):</span> se utiliza para dividir un valor por otro.<br>Ejemplo: 6 / 3</li><br>
                  <li><span class="sres">Módulo (%):</span> devuelve el residuo de una división.<br>Ejemplo: 7 % 3 devuelve 1 (ya que 7 dividido por 3 da un residuo de 1).</li><br>
                  <li><span class="sres">Potencia (**):</span> se utiliza para elevar un valor a una potencia determinada.<br>Ejemplo: 2 ** 3 devuelve 8 (ya que 2 elevado a la potencia de 3 es igual a 8).</li>
                </ol>
                <p>Estos son los operadores matemáticos básicos en Ruby, pero también hay otros operadores matemáticos avanzados, como operadores de comparación, operadores de asignación, operadores bit a bit, etc. que se utilizan en programación.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Operadores de comparación</summary>
                <p>En Ruby, los operadores de comparación se utilizan para comparar dos valores y devolver un valor booleano (verdadero o falso) que indica si la comparación es verdadera o falsa. Los operadores de comparación disponibles en Ruby son:</p>
                <ul>
                  <li><span class="sres">==  :</span>  Compara si dos valores son iguales.  Ejemplo: 3 == 3 devuelve <span class="scode">true</span>.</li>
                  <li><span class="sres">!=  :</span>  Compara si dos valores son diferentes.  Ejemplo: 3 != 4 devuelve <span class="scode">true</span>.</li>
                  <li><span class="sres"><  :</span>  Compara si un valor es menor que otro.  Ejemplo: 2 < 3 devuelve <span class="scode">true</span>.</li>
                  <li><span class="sres">>  :</span>  Compara si un valor es mayor que otro.  Ejemplo: 3 > 2 devuelve <span class="scode">true</span>.</li>
                  <li><span class="sres"><=  :</span>  Compara si un valor es menor o igual que otro.  Ejemplo: 2 <= 2 devuelve <span class="scode">true</span>.</li>
                  <li><span class="sres">>=  :</span>  Compara si un valor es mayor o igual que otro.  Ejemplo: 3 >= 3 devuelve <span class="scode">true</span>.</li>
                </ul>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Operadores Lógicos</summary>
                <p>En Ruby, <span class="sres"><b>&&</b></span>, <span class="sres"><b>| |</b></span>, y <span class="sres"><b>!</b></span> son operadores lógicos que se utilizan para evaluar expresiones booleanas y producir un resultado booleano. A continuación se describen los conceptos de cada uno de estos operadores:</p>
                <ul>
                  <li><span class="sres"><b>&&</b> (AND):</span> Devuelve true si ambas expresiones son verdaderas, de lo contrario devuelve false.<br>
                  <span class="scode">Ejemplo:</span> true && false devuelve false, mientras que true && true devuelve true.</li><br>
                  <li><span class="sres"><b>| |</b> (OR):</span> Devuelve true si al menos una de las expresiones es verdadera, de lo contrario devuelve false.<br>
                  <span class="scode">Ejemplo:</span> false | | true devuelve true, mientras que false | | false devuelve false.</li><br>
                  <li><span class="sres"><b>!</b> (NOT):</span> Devuelve el opuesto booleano de la expresión. Es decir, si la expresión es verdadera, devuelve false, y si la expresión es falsa, devuelve true.<br>
                  <span class="scode">Ejemplo:</span> !true devuelve false, mientras que !false devuelve true.</li>
                </ul>
                <p>Es importante tener en cuenta que estos operadores se evalúan de izquierda a derecha, y que tienen precedencia según la siguiente jerarquía: <span class="sres"><b>!</b></span> tiene la mayor precedencia, seguido de <span class="sres"><b>&&</b></span>, y finalmente <span class="sres"><b>| |</b></span>. Para cambiar el orden de evaluación, se pueden utilizar paréntesis.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Control Flow</summary>
                <p>La estructura de control de flujo se utiliza para controlar el flujo de ejecución del programa. Algunos ejemplos de estructuras de control de flujo en Ruby incluyen:</p>
                <h3>Condicionales</h3>
                  <ul>
                    <li><span class="scode"><b>if</b></span><b> (si):</b> Se utiliza para ejecutar un bloque de código si una condición es verdadera.</li>
                    <li><span class="scode"><b>elsif</b></span><b> (si no, si):</b> Se utiliza junto con if para evaluar una condición adicional si la primera condición es falsa.</li>
                    <li><span class="scode"><b>else</b></span><b> (si no):</b> Se utiliza junto con if y elsif para ejecutar un bloque de código si ninguna de las condiciones anteriores es verdadera.</li>
                    <li><span class="scode"><b>unless</b></span><b> (a menos que):</b> Se utiliza para ejecutar un bloque de código si una condición es falsa.</li>
                    <span><a href="#condition">(ver ejemplos)</a></span>
                  </ul>                  
                <h3>Bucles</h3>
                  <ul>
                  <li><span class="scode"><b>while</b></span><b> (mientras):</b> Se utiliza para ejecutar un bloque de código mientras una condición sea verdadera.</li>
                  <li><span class="scode"><b>until</b></span><b> (hasta que):</b> Se utiliza para ejecutar un bloque de código hasta que una condición sea verdadera.</li>
                  <li><span class="scode"><b>for</b></span><b> (para):</b> Se utiliza para iterar sobre una colección de objetos.</li>
                  <li><span class="scode"><b>in</b></span><b> (en):</b> Se utiliza junto con for para especificar la colección de objetos a iterar.</li>
                  <li><span class="scode"><b>times</b></span><b> (veces):</b> Se utiliza para ejecutar un bloque de código un número específico de veces.</li>
                  <span><a href="#bucles">(ver ejemplos)</a></span>
                  </ul>
                <h3>Estructura</h3>
                  <ul>
                  <li><span class="scode"><b>case</b></span><b> (caso):</b> Se utiliza para evaluar una expresión en diferentes casos y ejecutar un bloque de código correspondiente.</li>
                  <li><span class="scode"><b>when</b></span><b> (cuando):</b> Se utiliza junto con case para especificar una condición a evaluar.</li>
                  <span><a href="#structure">(ver ejemplos)</a></span>
                  </ul>
                <h3>Control de Bucles</h3>
                  <ul>
                  <li><span class="scode"><b>next</b></span><b> (siguiente):</b> Se utiliza para saltar a la siguiente iteración de un bucle (while, until, for).</li>
                  <li><span class="scode"><b>break</b></span><b> (romper):</b> Se utiliza para salir de un bucle (while, until, for).</li>
                  <li><span class="scode"><b>redo</b></span><b> (repetir):</b> Se utiliza para repetir la iteración actual en un bucle (while, until, for) desde el principio.</li>
                  <li><span class="scode"><b>retry</b></span><b> (reintentar):</b> Se utiliza para volver a intentar ejecutar un bloque de código desde el principio, generalmente después de haber capturado una excepción.</li>
                  </ul>
                  <p>En conclusión, Ruby ofrece una variedad de estructuras de control de flujo que permiten a los desarrolladores escribir programas más complejos y poderosos. La mayoría de las estructuras de control de flujo en Ruby tienen una sintaxis clara y fácil de entender.</p>
                  <p>Es importante tener en cuenta que un uso excesivo de estructuras de control de flujo puede dificultar la lectura y el mantenimiento del código. Por lo tanto, es recomendable utilizar estructuras de control de flujo de manera efectiva y en combinación con otras técnicas de programación para escribir código claro y fácil de entender.</p>
                  <p>Además, Ruby también ofrece varias instrucciones de control de bucles que permiten a los desarrolladores tener un mayor control sobre la ejecución de los bucles y la iteración. La comprensión y el uso efectivo de estas instrucciones son esenciales para escribir código eficiente y funcional.</p>

                <img  id="condition" class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>1. if | elsif | else</b></span> es muy común en Ruby para controlar diferentes casos que pueden ocurrir dentro de una estructura condicional.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 700px;">
                    <img src="/assets/img/ruby/rb1/cf_if_elsif_else.png" alt="if elsif">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">
                
                <p><span class="sres"><b>2. unless</b></span> es una estructura de control de flujo que se utiliza para ejecutar una sección de código solo si una condición no se cumple. En otras palabras, unless es el opuesto de if.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 230px;">
                    <img src="/assets/img/ruby/rb1/cf_unless.png" alt="unless">
                  </div>
                </div>
                <p>En este ejemplo, la estructura unless se utiliza para evaluar si la variable edad es menor que 18. Si la edad es menor que 18, se imprime "Eres menor de edad". Si la edad es mayor o igual a 18, se imprime "Eres mayor de edad".</p>
                <p>En resumen, unless es una estructura de control de flujo útil para ejecutar una sección de código solo si una condición no se cumple.</p>

                <img id="bucles" class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>3. do</b></span> se utiliza para indicar el inicio del bloque de código que se ejecutará para cada elemento de la colección, y end se utiliza para indicar el final del bloque de código. </p>
                <p>El siguiente es un ejemplo simple de cómo usar do con el método each para iterar sobre una matriz e imprimir cada elemento:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 280px;">
                    <img src="/assets/img/ruby/rb1/cf_do.png" alt="ruby do">
                  </div>
                </div>
                <p>En este ejemplo, la variable nombres contiene una matriz de tres nombres. El método each se utiliza para iterar sobre cada elemento de la matriz. La estructura do se utiliza para delimitar el bloque de código que se ejecutará junto con cada elemento del array. En este caso, el bloque de código contiene una única línea que imprime el nombre actual en la matriz.</p>
                <p>El resultado de este código sería:</p>
                <div class="pb16">
                  <code>
                    <pre class="codigo">
<span class="scom">El nombre es Ana</span>
<span class="scom">El nombre es María</span>
<span class="scom">El nombre es Juan</span></pre>
                  </code>
                </div>
                <p>Es importante tener en cuenta que en Ruby, los bloques pueden delimitarse de varias formas diferentes, como do y end o { y }. En general, se recomienda usar <b>do</b> y <b>end</b> para bloques de varias líneas y <b>{ }</b> para bloques de una sola línea.</p>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>4. while</b></span> es una estructura de control de flujo útil en Ruby que permite ejecutar un bloque de código repetidamente mientras se cumple una condición específica. Sin embargo, es importante utilizarla con cuidado para evitar ciclos infinitos.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 750px;">
                    <img src="/assets/img/ruby/rb1/cf_while.png" alt="while">
                  </div>
                </div>
                <p>Mientras la condición sea verdadera, el bloque de código se ejecutará una y otra vez. Cuando la condición se vuelve falsa, el programa saldrá del ciclo y continuará con el resto del código.</p>
                <p>Es importante tener en cuenta que la condición de while debe actualizarse adecuadamente dentro del bloque de código para evitar que el ciclo se ejecute infinitamente. Si la condición no cambia nunca, el programa se quedará atrapado en un ciclo infinito.</p>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>5. until</b></span> es una estructura de control de flujo útil en Ruby que permite ejecutar un bloque de código repetidamente hasta que se cumpla una condición específica. Esta estructura se utiliza principalmente cuando se quiere evaluar una condición en términos negativos.</p>
                <p>A diferencia de la estructura while, que se ejecuta mientras una condición es verdadera, la estructura until se ejecuta mientras una condición es falsa. Ambas estructuras son similares y se utilizan para controlar el flujo de un programa, pero until se puede utilizar cuando la condición que se quiere evaluar es más natural expresarla en términos negativos.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 600px;">
                    <img src="/assets/img/ruby/rb1/cf_until.png" alt="until">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>6. for</b></span> es una estructura de control de flujo en Ruby que permite iterar sobre una colección de elementos, como un arreglo o un rango de números. Aunque no es tan común como otras estructuras como each y map, sigue siendo una opción válida y útil en algunos casos.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 600px;">
                    <img src="/assets/img/ruby/rb1/cf_for.png" alt="ruby for">
                  </div>
                </div>
                <p>Es importante tener en cuenta que en Ruby, es más común utilizar otras estructuras de control de flujo como each y map para iterar sobre colecciones de elementos, ya que son más flexibles y poderosas que la estructura for. Sin embargo, for sigue siendo una opción válida y útil en algunos casos.</p>
                
                <img id="structure" class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>7. case | when</b></span> son palabras clave en el lenguaje de programación Ruby que se utilizan para realizar una serie de comprobaciones de igualdad en una expresión dada.</p>
                <p>Por ejemplo, el siguiente código en Ruby utiliza case y when para determinar si un número es positivo, negativo o cero:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 250px;">
                    <img src="/assets/img/ruby/rb1/cf_case_when.png" alt="case_when">
                  </div>
                </div>
                <p>En este ejemplo, el valor de num es -5, lo que significa que la condición en el último when se cumple y se ejecuta la línea puts "El número es negativo".</p>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <p><span class="sres"><b>8. times</b></span> es un método de Ruby que se utiliza para ejecutar un bloque de código un número específico de veces. Se utiliza comúnmente para ejecutar un bloque de código un número fijo de veces, por ejemplo, para imprimir una línea de texto varias veces.</p>
                <p>La sintaxis básica de .times es la siguiente:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 300px;">
                    <img src="/assets/img/ruby/rb1/cf_times.png" alt="ruby times">
                  </div>
                </div>
                <p>En este ejemplo, el bloque de código se ejecutará 5 veces y en cada iteración imprimirá "I am learning in codeable!". El resultado sería:</p>
                <div class="pb16">
                  <code>
                    <pre class="codigo">
<span class="scom">I am learning in codeable!</span>
<span class="scom">I am learning in codeable!</span>
<span class="scom">I am learning in codeable!</span>
<span class="scom">I am learning in codeable!</span>
<span class="scom">I am learning in codeable!</span></pre>
                  </code>
                </div>
                <hr>
              </details>

          </details>
          <p class="piepag">Resumen, Datos (Concepto, Tipos), Imprimir (puts y print), Concatenar / Interpolar, Comentar en el código, Operadores Matemáticos, Operadores de comparación, Operadores Lógicos, Control Flow.</p>

          <details>
            <summary class="sub manito">Ruby Basic 2</summary>

              <details>
                <summary class="subin manito">Arrays</summary>
                <h2>Concepto</h2>
                <p>Un array es una colección ordenada de elementos del mismo tipo de datos, que se pueden acceder y manipular a través de un índice numérico. Los arrays en Ruby pueden contener cualquier tipo de objeto, incluyendo otros arrays.</p>
                <p>Los arrays en Ruby se definen utilizando corchetes [ ] y separando los elementos por comas.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 300px;">
                    <img src="/assets/img/ruby/rb2/Arrays.png" alt="Arrays">
                  </div>
                </div>
                <p>Además, Ruby proporciona varios métodos útiles para trabajar con arrays, como por ejemplo:</p>
                <ul>
                  <li><span class="scode">length o size:</span> Obtenemos el número de elementos de un array.</li>
                  <li><span class="scode">join:</span> Une los elementos de un array en una cadena de texto.</li>
                  <li><span class="scode">sort:</span> Ordena los elementos de un array.</li>
                  <li><span class="scode">reverse:</span> Invierte el orden de los elementos en un array.</li>
                </ul>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 370px;">
                    <img src="/assets/img/ruby/rb2/methods.png" alt="metodos">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Indice de un Array</h2>
                <p>Cada elemento dentro de un array se identifica mediante un índice numérico que comienza en cero y se incrementa en uno para cada elemento adicional.</p>
                <p>Podemos acceder a un elemento específico en el array utilizando su índice. El primer elemento del array tiene un índice de 0, el segundo tiene un índice de 1, y así sucesivamente. Por lo tanto, para acceder al primer elemento del array (1), utilizamos el índice 0:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 260px;">
                    <img src="/assets/img/ruby/rb2/IndiceArray.png" alt="Indice Array">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Nested Arrays (Arreglo dentro de un arreglo)</h2>
                <p>Los nested arrays (arrays dentro de arrays) son una estructura de datos que permiten almacenar una colección de elementos, donde uno o más de los elementos son a su vez arrays.</p>
                <p>En otras palabras, un nested array es un array que contiene otros arrays como elementos. Esto permite representar estructuras de datos más complejas, como matrices, tablas, y listas de listas.</p> 
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 400px;">
                    <img src="/assets/img/ruby/rb2/NestedArray.png" alt="nested array">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Arrays Operators (Operadores de arreglos)</h2>
                <p>Los operadores de arrays en Ruby son un conjunto de métodos y símbolos que se utilizan para realizar operaciones comunes en arrays. Estos operadores son una parte importante del lenguaje Ruby, ya que permiten manipular y transformar arrays de manera eficiente y legible.</p>
                <p>Los operadores de arrays más comunes en Ruby incluyen:</p>
                <p><span class="sres"><b>+ :</b></span> Se utiliza para <span class="sres"><b>"concatenar"</b></span> dos arrays.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 320px;">
                    <img src="/assets/img/ruby/rb2/ArrayConcat.png" alt="concat array">
                  </div>
                </div>
                <p><span class="sres"><b>- :</b></span> Se utiliza para <span class="sres"><b>"eliminar"</b></span> los elementos del primer array que se repitan en el segundo array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 220px;">
                    <img src="/assets/img/ruby/rb2/Arrayresta.png" alt="resta array">
                  </div>
                </div>
                <p><span class="sres"><b>& :</b></span> El operador de <span class="sres"><b>intersección</b></span> devuelve un nuevo array que contiene sólo los elementos que están presentes en ambos arrays.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 220px;">
                    <img src="/assets/img/ruby/rb2/ArrayIntersec.png" alt="intersección array">
                  </div>
                </div>
                <p><span class="sres"><b>| :</b></span> El operador de <span class="sres"><b>unión</b></span> devuelve un nuevo array que contiene todos los elementos de "ambos arrays", sin duplicados.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 310px;">
                    <img src="/assets/img/ruby/rb2/ArrayUnion1.png" alt="union array">
                  </div>
                </div>
                <p class="scoder"><i>También es posible utilizar los métodos intersection y union para realizar estas operaciones.</i></p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 380px;">
                    <img src="/assets/img/ruby/rb2/ArrayUnion2.png" alt="union array">
                  </div>
                </div><br>
                <p><span class="sres"><b>* :</b></span> Es utilizado para <span class="sres"><b>"repetir"</b></span> un array un número determinado de veces.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 380px;">
                    <img src="/assets/img/ruby/rb2/Arrayrepeat.png" alt="repetir array">
                  </div>
                </div>
                <p><span class="sres"><b>[ ] :</b></span> Lo utilizamos para acceder a un elemento específico de un array mediante su índice. También se puede utilizar para acceder a un rango de elementos.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 230px;">
                    <img src="/assets/img/ruby/rb2/ArrayIndice.png" alt="indice array">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Arrays Methods (Metódos en un arreglo)</h2>
                <p>En Ruby, los arrays tienen una amplia variedad de métodos disponibles para manipularlos y acceder a ellos. Algunos de los métodos más comunes son:</p>
                <p><span class="sres"><b>at :</b></span> Podemos acceder a un elemento específico de un array mediante su índice. Es equivalente a utilizar el operador [ ].</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 230px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodAt.png" alt="at array">
                  </div>
                </div>
                <p><span class="sres"><b>push :</b></span> Muy utilizado para <span class="sres"><b>"agregar un elemento al final"</b></span> de un array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 280px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodPush.png" alt="push array">
                  </div>
                </div>
                <p><span class="sres"><b>shift :</b></span> Se utiliza para <span class="sres"><b>"eliminar el primer elemento"</b></span> de un array y devolverlo.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 230px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodShift.png" alt="shift array">
                  </div>
                </div>
                <p><span class="sres"><b>length o size :</b></span> Estos métodos se utilizan para obtener el tamaño de un array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 170px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodLengthSize.png" alt="length_size array">
                  </div>
                </div>
                <p><span class="sres"><b>sort :</b></span> utilizado para <span class="sres"><b>"ordenar"</b></span> los elementos de un array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 290px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodSort.png" alt="sort array">
                  </div>
                </div>
                <p><span class="sres"><b>reverse :</b></span> Con reverse podemos <span class="sres"><b>"invertir el orden"</b></span> de los elementos de un array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 290px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodReverse.png" alt="reverse array">
                  </div>
                </div>
                <p><span class="sres"><b>compact :</b></span> Se utiliza para <span class="sres"><b>"eliminar los elementos nulos"</b></span> de un array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 250px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodCompact.png" alt="compact array">
                  </div>
                </div>
                <p><span class="sres"><b>map o collect :</b></span> Estos métodos se utilizan para <span class="sres"><b>"transformar los elementos"</b></span> de un array mediante una función.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 180px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodMapCollect.png" alt="map_collect array">
                  </div>
                </div>
                <p><span class="sres"><b>each :</b></span> Lo usamos para iterar sobre los elementos de un array.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 190px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodEach.png" alt="each array">
                  </div>
                </div>
                <p class="scoder"><i>NOTA: each y map hacen los mismo a diferencia que each solo opera dentro del arreglo y fuera de él no se conserva su nuevos valores, en cambio maps puede asignar el valor a una nueva variable y usarse fuera del arreglo.</i></p>
                <p><span class="sres"><b>each_with_index :</b></span> Se utiliza para iterar sobre un array y al mismo tiempo acceder al índice de cada elemento. Este método toma un bloque que recibe dos argumentos: el primer argumento es el valor del elemento y el segundo argumento es el índice del elemento.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 450px;">
                    <img src="/assets/img/ruby/rb2/ArrayMetodEachIndex.png" alt="eachWithIndex array">
                  </div>
                </div>
                <p>Estos son solo algunos de los métodos disponibles para los arrays en Ruby. Hay muchos más que puedes explorar en la documentación oficial de Ruby.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Hashes</summary>
                <h2>Concepto</h2>
                <p>Un hash es una colección de pares <span class="sres">key-value</span>, donde cada <span class="sres">key</span> está asociada a un <span class="sres">value</span> único. Los hashes se definen utilizando llaves <span class="sres">{ }</span> y los pares <span class="sres">key-value</span> se separan por comas.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 400px;">
                    <img src="/assets/img/ruby/rb2/hash.png" alt="hash">
                  </div>
                </div>
                <p>Las keys pueden ser cualquier objeto de Ruby, pero generalmente se utilizan símbolos o cadenas de texto. Los valores también pueden ser cualquier objeto de Ruby, incluyendo otros hashes.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 460px;">
                    <img src="/assets/img/ruby/rb2/hashes.png" alt="hashes">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Symbol</h2>
                <p>los símbolos son objetos inmutables que se utilizan como identificadores únicos en el programa. Los símbolos se definen anteponiendo los dos puntos <span class="sres"><b>( : )</b></span> al nombre del símbolo.</p>
                <div class="pb16">
                  <code>
                    <pre class="codigo">
<span class="scode">:nombre</span>
<span class="scode">:edad</span></pre>
                  </code>
                </div>
                <p>Los símbolos son útiles porque ocupan menos memoria que las cadenas de texto, y porque son más eficientes para comparar y buscar en el programa.</p>
                <p>Dentro de un hash el símbolo se utiliza como key y se convierte automáticamente en un símbolo.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 300px;">
                    <img src="/assets/img/ruby/rb2/hashSymbol.png" alt="hash symbol">
                  </div>
                </div>
                <p>En este caso, nombre: es un símbolo que se utiliza como key en el hash, y "Juan" es el value asociado a la key.</p>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Methods in Hashes</h2>
                <p>En Ruby, un método es una pieza de código que realiza una tarea específica y se puede llamar en cualquier parte del programa.</p>
                <p>Algunos ejemplos de metodos:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 630px;">
                    <img src="/assets/img/ruby/rb2/hashMethod.png" alt="hash method">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>MAP in Hashes</h2>
                <p>En Ruby, el método <span class="scode"><b>.map</b></span> se puede utilizar en una hash para transformar los values de un hash, pero no las keys. El método <span class="scode"><b>.map</b></span> devuelve un array con los resultados de la operación realizada en cada valor del hash.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 370px;">
                    <img src="/assets/img/ruby/rb2/hashMap.png" alt="hash map">
                  </div>
                </div>
                <hr>
              </details>

          </details>
          <p class="piepag">Arrays : Concepto, Indice de un array, Nested Arrays, Arrays Operators, Arrays Methods.
            <br>Hashes : Concepto, Symbol, Methods in Hashes, MAP in Hashes.
          </p>

          <details>
            <summary class="sub manito">Ruby Methods</summary>

              <details>
                <summary class="subin manito">Concepto y Ejemplos</summary>
                <p>En Ruby, un método es una pieza de código que se puede llamar o invocar para realizar una tarea específica. Los métodos son definidos dentro de clases o módulos, y pueden ser públicos, privados o protegidos, lo que afecta su visibilidad y accesibilidad.</p>
                <p>Para definir un método en Ruby, se utiliza la palabra clave def seguida del nombre del método y sus argumentos entre paréntesis (si los tiene). Luego, el cuerpo del método se escribe entre las palabras clave def y end.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 400px;">
                    <img src="/assets/img/ruby/rmethods/Methods.png" alt="Methods Ruby">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Invoque Methods (llamando al método)</h2>
                <p>Para invocar o llamar a un método lo hacemos con el nombre del método seguido de unos parentesis donde debemos indicar un argumento para el parámetro, (entiéndase como asignarle un valor a una variable)</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 350px;">
                    <img src="/assets/img/ruby/rmethods/MethodInvoque.png" alt="Invoque Methods">
                  </div>
                </div>
                
                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Ejemplos</h2>
                <p><span class="scoder"><b>Di hola:</b></span> Crear el método "greeting" lo hace más legible, ¿verdad?</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 380px;">
                    <img src="/assets/img/ruby/rmethods/MethodExampHola.png" alt="Ejemplo Hola">
                  </div>
                </div><br>
                <p><span class="scoder"><b>Calculadora de IMC:</b></span> podemos reutilizar "get_float" para obtener el peso y la altura del usuario. Y "recommendation" hace que el código sea más legible.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 550px;">
                    <img src="/assets/img/ruby/rmethods/MethodExampBMI.png" alt="Ejemplo bmi">
                  </div>
                </div><br>
                <p><span class="scoder"><b>Multiplicador:</b></span> "get_positive", "get_multiples" y "format_multiples" dan al código una mejor estructura. Si queremos cambiar la forma en que se imprimen los múltiplos, simplemente podemos modificar "format_multiple". Con "get_multiples" podemos generar tantos múltiplos como queramos, no solo 20.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 710px;">
                    <img src="/assets/img/ruby/rmethods/MethodExampMultiply.png" alt="Ejemplo Multiplicador">
                  </div>
                </div>
                <p>El uso de métodos nos permite cortar nuestro código en pequeños pedazos, haciéndolo más legible, comprobable y mantenible.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Return Explicit and Implicit</summary>
                <p>En Ruby, hay dos formas diferentes en las que los métodos pueden devolver valores: "Return Explicit" y "Return Implicit".</p>
                <p><span class="sres"><b>Explicit Return :</b></span> se refiere a cuando se utiliza la palabra clave "return" para indicar que una función o método debe devolver un valor específico.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 130px;">
                    <img src="/assets/img/ruby/rmethods/MethodExplicit.png" alt="Method Explicit">
                  </div>
                </div>
                <p><span class="sres"><b>Implicit return :</b></span> se produce cuando la última línea de una función o método es una expresión que se evalúa como el valor de retorno.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 130px;">
                    <img src="/assets/img/ruby/rmethods/MethodImplicit.png" alt="Method Implicit">
                  </div>
                </div>
                <p>Es importante tener en cuenta que la mayoría de las veces en Ruby se utiliza el retorno implícito, ya que es más conciso y hace que el código sea más fácil de leer. Sin embargo, en ciertas situaciones, puede ser necesario utilizar el retorno explícito para devolver un valor específico.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Default Arguments</summary>
                <p>Los "default arguments" son valores predeterminados que se pueden asignar a los parámetros de un método. Esto significa que si no se proporciona un argumento al invocar al método, se usará el valor predeterminado.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 630px;">
                    <img src="/assets/img/ruby/rmethods/MethodDefaultArgum.png" alt="Default Argument">
                  </div>
                </div>
                <p>En este caso, el segundo parametro tiene un valor predeterminado, mientras que el primer y tercer parametro son obligatorios. Si se invoca al método con dos argumentos, el segundo parametro conserva el valor predeterminado como argumento y el tercer parametro recibirá el segundo argumento que se proporciona.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Truthy y Falsy</summary>
                <p>En Ruby, un valor "truthy" se refiere a cualquier valor que se evalúa como verdadero en un contexto booleano. Por otro lado, un valor "falsy" se refiere a cualquier valor que se evalúa como falso en un contexto booleano.</p>
                <p>En general, los siguientes valores se consideran <span class="sres">Truthy</span> en Ruby:</p>
                <ul>
                  <li>Cualquier valor numérico diferente de cero (por ejemplo, 1, 3.14, -5).</li>
                  <li>Cualquier cadena de caracteres no vacía (por ejemplo, "hola", "Ruby").</li>
                  <li>Cualquier objeto (por ejemplo, una instancia de una clase personalizada).</li>
                  <li>Cualquier arreglo, hash o estructura de datos que no esté vacía.</li>
                  <li>El valor booleano true.</li>
                </ul>
                <p>Por otro lado, los siguientes valores se consideran <span class="sres">Falsy</span> en Ruby:</p>
                <ul>
                  <li>El valor booleano false.</li>
                  <li>El valor nulo (nil).</li>
                  <li>El número cero (0).</li>
                  <li>Una cadena de caracteres vacía ("").</li>
                  <li>Un arreglo, hash o estructura de datos vacía.</li>
                </ul>
                <p>Es importante tener en cuenta que el concepto de Truthy y Falsy en Ruby es específico del contexto booleano. En otros contextos, estos mismos valores pueden tener un comportamiento diferente. Por ejemplo, el número cero puede ser válido en un contexto numérico, pero se evalúa como Falsy en un contexto booleano.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Keywords Arguments</summary>
                <p>En Ruby, los  "keyword arguments" son una característica que permite pasar argumentos a un método mediante la especificación de sus nombres explícitamente.</p>
                <p>Por defecto, los argumentos de un método en Ruby se pasan por orden de posición, lo que significa que el primer argumento que se especifica se asigna al primer parámetro del método, el segundo argumento se asigna al segundo parámetro, y así sucesivamente. Sin embargo, cuando se utilizan Keywords Arguments, el orden de los argumentos ya no importa, ya que se especifican explícitamente los nombres de los parámetros que se están pasando.</p>
                <p>Para definir un método con Keywords Arguments, se utiliza el símbolo ( <span class="sres"><b>:</b></span> ) se coloca después del nombre del argumento y antes del valor predeterminado asignado al mismo (si es que se le ha asignado alguno).</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 330px;">
                    <img src="/assets/img/ruby/rmethods/MethodKeywordArgum.png" alt="Keywords Argument">
                  </div>
                </div>
                <p>En este ejemplo, el método saludar toma dos argumentos de palabras clave: <span class="scode">nombre:</span> y <span class="scode">mensaje:</span>. Cuando se llama a este método, se debe especificar el nombre de cada argumento junto con su valor. De esta manera, el orden de los argumentos ya no importa, y es más fácil entender qué valor se está pasando a cada parámetro. Los argumentos de palabras clave también pueden tener valores predeterminados, lo que permite omitirlos al llamar al método y usar su valor por defecto.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 330px;">
                    <img src="/assets/img/ruby/rmethods/MethodKeywordArgum2.png" alt="Keywords Argument">
                  </div>
                </div>
                <p>En este ejemplo, el argumento mensaje tiene un valor predeterminado de "Hola", por lo que se puede llamar al método sin especificar este argumento.</p>
                <hr>
              </details>

              <details>
                <summary class="subin manito">Splat Operator</summary>
                <p>El Splat Operator se representa por el símbolo ( <span class="scoder">*</span> ) y se utiliza para indicar que un parámetro puede recibir cierta cantidad de argumentos, que serán <span class="sres">tratados como un arreglo</span> dentro del método.</p>
                <p>Cuando se utiliza el Splat Operator en el contexto de los parámetros de un método, puede aparecer tanto al inicio como al final de la lista de parámetros, aunque es más común encontrarlo al final. Si se utiliza al inicio, indica que el método espera al menos un argumento, y los demás argumentos opcionales pueden ser proporcionados como un arreglo. Si se utiliza al final, indica que el método espera cualquier cantidad de argumentos, y que éstos serán capturados en un solo arreglo.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 450px;">
                    <img src="/assets/img/ruby/rmethods/MethodSplatOp.png" alt="Splat Operator">
                  </div>
                </div>
                <p>En este ejemplo, el Splat Operator indica que el <span class="scode">método sum</span> puede recibir cualquier cantidad de argumentos, que serán tratados como un <span class="scode">Array</span> llamado numbers dentro del <span class="scode">método sum</span>. Luego, se utiliza un ciclo <span class="scode">each</span> para sumar los números del arreglo y devolver el resultado.</p>
                <hr>
              </details>              

              <details>
                <summary class="subin manito">Double Splat Operator</summary>
                <p>En Ruby, el Double Splat Operator ( <span class="scoder">**</span> ), también conocido como "hash rocket", permite a los parametros recibir argumentos del tipo Keywords Arguments los cuales serán <span class="sres">tratados como un Hash</span>. El Double Splat Operator convierte estos Keywords Arguments en un hash con sus keys y values correspondientes.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 530px;">
                    <img src="/assets/img/ruby/rmethods/MethodDoubleSplat.png" alt="Double Splat">
                  </div>
                </div>
                <hr>
              </details>

          </details>
          <p class="piepag">Concepto, Retorno Implicito y Explicito, Default Arguments, Truthy y Falsy, Keywords Arguments, Splat Operator, Double Splat Operator.</p>

          <!-- <details> -->
            <summary class="sub manito">Ruby Blocks</summary>
              
              <details>
                <summary class="subin manito">Bloques</summary>
                <h2>Concepto</h2>
                <p>Un bloque en Ruby es un fragmento de código que se puede asociar a la llamada a un método. Se define como un conjunto de instrucciones encerradas entre las palabras clave <span class="scode"><b>do</b></span> y <span class="scode"><b>end</b></span> o entre llaves <span class="scode"><b>{ }</b></span>.</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 330px;">
                    <img src="/assets/img/ruby/blocks/Bloque.png" alt="block concept">
                  </div>
                </div>
                <ol>
                  <li><span class="scode"><b>do end</b></span> es más adecuado para bloques que abarcan <span class="scoder">"varias líneas"</span> de código, ya que su formato puede ser más fácil de leer y seguir en bloques más largos.</li>
                  <li><span class="scode"><b>{ }</b></span> es más adecuado para bloques que abarcan <span class="scoder">"una sola línea"</span> de código, ya que su formato más compacto puede ayudar a mantener el código más legible.</li>
                </ol>

                <img class="chr" src="/assets/img/hr.png" alt="hr">
                
                <h2>Método Encadenable</h2>
                <p>Ruby nos permite encadenar varios métodos juntos en una sola línea de código.</p>
                <p>Por ejemplo, el método <span class="scode">.collect</span> en Ruby devuelve un arreglo, lo que significa que se puede encadenar con otros métodos que operen en arreglos, como <span class="scode">.with_index</span> por ejemplo:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 500px;">
                    <img src="/assets/img/ruby/blocks/BMetodEncaden.png" alt="metodo encadenable">
                  </div>
                </div>
                <p>Este código toma el array numbers, <span class="scode">.collect</span> itera con cada elemento del array y <span class="scode">.with_index</span> añade su índice a cada elemento (número), luego crea un nuevo arreglo con una cadena de texto por cada número (number) que contiene tanto su índice (index) como su valor.</p>
                <hr>




              </details>

              <details>
                <summary class="subin manito">Yield Keyword</summary>
                <p>Recordemos que al <span class="sres">"invocar un método"</span> -(llamar)- podemos pasarle argumentos a sus parametros, en algunos casos debemos pasar un <span class="sres">"bloque de código"</span>, ahí usamos <span class="scode"><b>Yield</b></span>.</p>
                <p><span class="scode"><b>Yield</b></span> es una palabra clave que se utiliza en un método para <span class="sres">"invocar"</span> a un bloque de código que <span class="sres">"se pasa al método"</span>. Cuando se ejecuta Yield, el control se transfiere al bloque de código que se pasó en la <span class="sres">"invocación del método"</span>. El bloque puede ejecutar cualquier código que se haya definido en él y puede tener argumentos si se definen en el método que llama al bloque.</p>
                <h2>Ejemplo sin parámetros</h2>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 380px;">
                    <img src="/assets/img/ruby/blocks/BYield.png" alt="Yield">
                  </div>
                </div>

                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Ejemplo con parámetros</h2>
                <p>Antes de ver el siguiente ejemplo debemos tener en cuenta que:</p>
                <ul>
                  <li>Los <span class="sres">métodos</span> que <b>"Tengan"</b> <span class="sres">parámetros</span> <b>"obligatoriamente"</b> deben recibir <span class="sres">argumentos</span>, estos se pasarán al momento de <span class="sres">invocar al método</span>.</li>
                  <li>Los bloques de código invocados por <span class="scode"><b>Yield</b></span> (dentro de un método) también pueden tener <span class="sres">parámetros</span> dentro de <span class="scoder"><b>| |</b></span>, estos reciben los <span class="sres">argumentos</span> que serán pasados al momento de la invocación que hace <span class="scode"><b>Yield</b></span>.</li>
                </ul>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 670px;">
                    <img src="/assets/img/ruby/blocks/BYieldParams.png" alt="Yield with params">
                  </div>
                </div>

                <img class="chr" src="/assets/img/hr.png" alt="hr">

                <h2>Ejemplo Yield Dinámico</h2>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 690px;">
                    <img src="/assets/img/ruby/blocks/BYieldDynamic.png" alt="Yield dinámico">
                  </div>
                </div>
                <hr>
              </details>

              <!-- <details> -->
                <summary class="subin manito">Procs</summary>
                <p>Un Proc es un objeto que representa un bloque de código que puede ser ejecutado en cualquier momento. Un Proc es similar a un bloque, pero se puede asignar a una variable y pasar como argumento a un método.</p>
                <p>Para definir un Proc en Ruby, se utiliza la palabra clave "proc" seguida de un bloque de código entre llaves o do/end:</p>
                <div class="ptb16">
                  <div class="codigo dg" style="grid-template-columns: 630px;">
                    <img src="/assets/img/ruby/blocks/BProcs.png" alt="Procs Ruby">
                  </div>
                </div>




              </details>

              <!-- <details> -->
                <summary class="subin manito">Lambdas</summary>




              </details>
              
            



          </details>
          <p class="piepag">Bloques : Concepto, Método Encadenable.<br>
            Yield Keywords : Concepto, Ejemplos.<br>
            Procs : 
          </p>

          <details>
            <summary class="sub manito">Ruby Classes</summary>
            

          </details>

          <details>
            <summary class="sub manito">Ruby Modules</summary>
            

          </details>

          <details>
            <summary class="sub manito">Ruby Files</summary>
            

          </details>

          <details>
            <summary class="sub manito">Ruby CSV JSON YAML</summary>
            

          </details>

          <details>
            <summary class="sub manito">Ruby Regex</summary>
            

          </details>

          <details>
            <summary class="sub manito">Ruby Exceptions and Testing</summary>
            

          </details>

          <details>
            <summary class="sub manito">Ruby HTTP</summary>
            

          </details>



          </div>
        </article>
          
          

      </section>
    </main>



    <footer class="wall-foot">      
      <div class="fut">
        <div>
          <img src="assets/img/foot/signature.jpg" alt="foot/signature" height="28px">
        </div>
        <div>
          <span>  © 2023 sponsored by {Codeable}</span>
        </div>
      </div>    
    </footer>
  </body>
</html>