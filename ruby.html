<!DOCTYPE html>
<html lang="es">
  <head>
    <title>Apuntes de Clase Codeable</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="estilos.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@200;500&display=swap" rel="stylesheet">
  </head>
  <body>
    <header>
        <nav>
          <ul>
            <li><a href="index.html"><img src="ico/ico_config.png" alt="icono config" height="16px"> Config</a>
              <ul>
                <li><a href="index.html#comand">Comandos Básicos</a></li>
                <li><a href="index.html#wsl">Install WSL</a></li>
                <li><a href="index.html#winter">Install windows terminal y ohmyzsh</a></li>
                <li><a href="index.html#ruby">Install Ruby</a></li>
                <li><a href="index.html#node">Install NodeJS</a></li>
                <li><a href="index.html#vsc">Install VSCode</a></li>
                <li><a href="index.html#git">Install Git</a></li>
                <li><a href="index.html#gh">Conociendo Github</a></li>
              </ul>
            </li>
            <li><a href="ruby.html"><img src="ico/ico_ruby.png" alt="icono ruby" height="15px"> Ruby</a>
              <ul>
                <li><a href="#">Basic 1</a></li>
                <li><a href="#">Basic 2</a></li>
                <li><a href="#">item 3</a></li>
                <li><a href="#">item 4</a></li>
                <li><a href="#">item 5</a></li>
                <li><a href="#">item 6</a></li>
              </ul>
            </li>
            <li><a href="html_css.html"><img src="ico/ico_htss.png" alt="icono html" height="15px"> HTML & CSS</a>
              <ul>
                <li><a href="#">item 1</a></li>
                <li><a href="#">item 2</a></li>
                <li><a href="#">item 3</a></li>
                <li><a href="#">item 4</a></li>
                <li><a href="#">item 5</a></li>
                <li><a href="#">item 6</a></li>
              </ul>
            </li>
            <li><a href="rails.html"><img src="ico/ico_rails.png" alt="icono rails" height="15px"> Rails</a>
              <ul>
                <li><a href="#">item 1</a></li>
                <li><a href="#">item 2</a></li>
                <li><a href="#">item 3</a></li>
                <li><a href="#">item 4</a></li>
                <li><a href="#">item 5</a></li>
                <li><a href="#">item 6</a></li>
              </ul>
            </li>
            <li><a href="js.html"><img src="ico/ico_JS.png" alt="icono JS" height="15px"> JavaScript</a>
              <ul>
                <li><a href="#">item 1</a></li>
                <li><a href="#">item 2</a></li>
                <li><a href="#">item 3</a></li>
                <li><a href="#">item 4</a></li>
                <li><a href="#">item 5</a></li>
                <li><a href="#">item 6</a></li>
             </ul>
            </li>
            <li><a href="react.html"><img src="ico/ico_React.png" alt="icono react" height="15px"> React</a>
              <ul>
                <li><a href="#">item 1</a></li>
                <li><a href="#">item 2</a></li>
                <li><a href="#">item 3</a></li>
                <li><a href="#">item 4</a></li>
                <li><a href="#">item 5</a></li>
                <li><a href="#">item 6</a></li>
             </ul>
            </li>
            <li><a href="capstone.html">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>
               Capstone</a>
              <ul>
                <li><a href="#">item 1</a></li>
                <li><a href="#">item 2</a></li>                
                <li><a href="#">item 3</a></li>
                <li><a href="#">item 4</a></li>
                <li><a href="#">item 5</a></li>
                <li><a href="#">item 6</a></li>
             </ul>
            </li>
          </ul>
        </nav>
    </header>
    <main>
      <section>
        <div class="main">
          <h1 id="comand"><img src="ico/ico_ruby.png" width="22px"> Ruby</h1>
            <details>
              <summary class="sub">Ruby Basic 1</summary>
                <p> </p>
                <details>
                  <summary class="sumary">Resumen</summary>
                  <p>Ruby es un lenguaje de programación de alto nivel, dinámico y orientado a objetos. Fue desarrollado por Yukihiro "Matz" Matsumoto en Japón a mediados de los 90. Ruby se destaca por su sintaxis clara y expresiva, y su enfoque en la programación fácil y agradable.</p>
                  <p>En Ruby, todo es un objeto, lo que significa que cada valor y función se representa como un objeto en tiempo de ejecución. Ruby cuenta con una gran cantidad de características y bibliotecas estándar que lo hacen adecuado para una amplia variedad de aplicaciones, desde la creación de scripts hasta el desarrollo web y de aplicaciones móviles.</p>
                  <p>Algunas de las características notables de Ruby incluyen:</p>
                  <p><ul>
                    <li>Una sintaxis fácil de leer y escribir que favorece la legibilidad y la simplicidad.</li>
                    <li>Un sistema de tipos dinámicos que permite una gran flexibilidad en la escritura de código.</li>
                    <li>Soporte integrado para programación orientada a objetos, incluyendo clases, objetos, métodos y herencia.</li>
                    <li>Un recolector de basura automático que administra automáticamente la memoria utilizada por el programa.</li>
                    <li>Bibliotecas estándar ricas que cubren una amplia variedad de áreas, desde programación de redes hasta procesamiento de texto.</li>
                  </ul></p>
                  <p>En resumen, Ruby es un lenguaje de programación poderoso y expresivo que se enfoca en hacer la programación fácil y agradable, lo que lo convierte en una opción popular para una amplia variedad de aplicaciones.</p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Datos (Concepto, Tipos)</summary>
                    <p>En Ruby, un dato es un valor que puede ser almacenado y manipulado en un programa. Los datos en Ruby pueden ser de diferentes tipos, como números, cadenas de texto, booleanos, arreglos, hashes, símbolos, expresiones regulares, rangos, nulos, entre otros.</p>
                    <p>Cada tipo de dato en Ruby tiene su propio conjunto de métodos y operaciones que se pueden utilizar para manipular y trabajar con ellos. Los datos se pueden asignar a variables para que puedan ser reutilizados en diferentes partes del programa, y también se pueden pasar como argumentos a métodos y funciones.</p>
                    <p>El concepto de datos es fundamental en la programación en Ruby, ya que cualquier programa que se escriba necesitará trabajar con algún tipo de dato en algún momento. Por lo tanto, es importante tener una comprensión clara de los diferentes tipos de datos disponibles en Ruby y cómo se pueden manipular para lograr los objetivos del programa.</p>
                    <p>En Ruby, existen varios tipos de datos, algunos de ellos son:</p>
                    <p>
                      <ol>
                        <li>Números enteros (Integer): se pueden representar como valores positivos o negativos sin fracciones.<br>Ejemplo: 1, 2, 3, -1, -2, -3, etc.</li><br>
                        <li>Números de coma flotante (Float): representan números reales con decimales.<br>Ejemplo: 1.23, 2.45, 3.14159, etc.</li><br>
                        <li>Cadenas de texto (String): una cadena de caracteres que se utiliza para representar texto.<br>Ejemplo: "Hola", "Mundo", "¡Hola, Mundo!", etc.</li><br>
                        <li>Booleanos (Boolean): un valor booleano puede ser verdadero (true) o falso (false).<br>Ejemplo: true, false.</li><br>
                        <li>Arreglos (Array): un arreglo es una colección ordenada de elementos, que pueden ser de cualquier tipo.<br>Ejemplo: [1, 2, 3], ["hola", "mundo"], etc.</li><br>
                        <li>Hashes (Hash): un hash es una colección de pares clave-valor, donde la clave se utiliza para acceder al valor.<br>Ejemplo: { "nombre" => "Juan", "edad" => 30 }, etc.</li><br>
                        <li>Símbolos (Symbol): un símbolo es una cadena de texto que se utiliza como identificador en lugar de una cadena de texto completa.<br>Ejemplo: :nombre, :edad, etc.</li><br>
                        <li>Expresiones regulares (Regexp): una expresión regular es una secuencia de caracteres que forman un patrón de búsqueda.<br>Ejemplo: /hola/, /[0-9]+/, etc.</li><br>
                        <li>Rangos (Range): un rango representa un conjunto de valores que se encuentran entre un valor inicial y un valor final.<br>Ejemplo: 1..10, 'a'..'z', etc.</li><br>
                        <li>Nulos (NilClass): representa la ausencia de un valor.<br>Ejemplo: nil.</li>
                      </ol>
                    </p>
                    <p>Estos son algunos de los tipos de datos en Ruby, aunque hay otros tipos de datos más complejos y especializados que se pueden utilizar en programación.</p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Imprimir (puts y print)</summary>
                    <p>En Ruby, tanto "print" como "puts" se utilizan para imprimir salida en la consola o terminal. Ambos métodos pueden imprimir cadenas de caracteres y objetos.</p>
                    <p>La diferencia entre "print" y "puts":</p>
                    <p><ul>
                      <li>"puts" agrega automáticamente un salto de línea al final de la salida impresa,</li>
                      <li>"print" imprimirá en la misma línea varios print (sin salto de línea).</li>
                    </ul></p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Concatenar / Interpolar</summary>
                    <p>En Ruby, concatenar y interpolar son dos formas diferentes de combinar cadenas de caracteres.</p>
                    <p>La concatenación se refiere a la unión de dos o más cadenas de caracteres en una sola cadena. En Ruby, se utiliza el operador de concatenación + para unir dos cadenas de caracteres. Por ejemplo:</p>
                      <code>
                        nombre = <font color="#89C363">"Juan"</font><br>
                        apellido = <font color="#89C363">"Pérez"</font><br>
                        nombre_completo = nombre + <font color="#89C363">" "</font> + apellido<br>
                        puts nombre_completo<br>
                        <font color="#8E918F"># Output: Juan Pérez</font>
                      </code>
                    <p>Como se puede ver en el ejemplo, el operador + se utiliza para concatenar las variables nombre y apellido con un espacio en blanco en el medio.</p>
                    <p>Por otro lado, la interpolación se refiere a la inclusión de valores de variables en una cadena de caracteres. En Ruby, se utiliza el signo de almohadilla # seguido de llaves {} para interpolar una variable en una cadena de caracteres. Por ejemplo:</p>
                      <code>
                        nombre = <font color="#89C363">"Juan"</font><br>
                        apellido = <font color="#89C363">"Pérez"</font><br>
                        nombre_completo = <font color="#89C363">"#{nombre} #{apellido}"</font><br>
                        puts nombre_completo<br>
                        <font color="#8E918F"># Output: Juan Pérez</font>
                      </code>
                    <p>En este caso, en lugar de utilizar el operador + para concatenar las variables nombre y apellido, se utiliza la interpolación para incluir el valor de las variables en la cadena de caracteres utilizando las llaves {} y el signo de almohadilla #.</p>
                    <p>En resumen, la principal diferencia entre concatenar e interpolar en Ruby es que la concatenación une dos o más cadenas de caracteres en una sola, mientras que la interpolación permite incluir el valor de una variable en una cadena de caracteres.</p>
                    <p></p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Comentar en el código</summary>
                    <p>En Ruby, se pueden utilizar dos tipos de comentarios para agregar notas y explicaciones al código sin que afecten su ejecución: comentarios de una sola línea y comentarios de varias líneas.</p>
                    <p>Los comentarios de una sola línea comienzan con el símbolo # y se extienden hasta el final de la línea. Por ejemplo:</p>
                      <code>
                        <font color="#8E918F"># Este es un comentario de una sola línea</font><br>
                        valor = <font color="#FB7B70">42 </font><font color="#8E918F"># Este es otro comentario de una sola línea</font>
                      </code>
                    <p>Los comentarios de varias líneas se encierran entre =begin y =end. Por ejemplo:</p>
                      <code>
                        <font color="#8E918F">=begin<br>
                          Este es un comentario<br>
                          de varias líneas<br>
                          =end</font>
                      </code>
                    <p>Estos son los usos más comunes de los comentarios en Ruby:</p>
                    <p>
                      <ul>
                        <li>Documentación: se pueden agregar comentarios para documentar el código y explicar su funcionalidad.</li>
                        <li>Depuración: se pueden agregar comentarios para deshabilitar temporalmente secciones de código o para agregar notas de depuración.</li>
                        <li>Explicación: se pueden agregar comentarios para explicar la intención detrás del código, el propósito de las variables o las decisiones de diseño.</li>
                      </ul>
                    </p>
                    <p>Es importante recordar que los comentarios no afectan la ejecución del código y solo son visibles para los desarrolladores que leen el código fuente. Los comentarios deben utilizarse de manera efectiva para hacer el código más legible y fácil de entender para los desarrolladores que lo mantienen y mejoran con el tiempo.</p>              
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Operadores Matemáticos</summary>
                    <p>En programación, los operadores matemáticos son símbolos que se utilizan para realizar operaciones matemáticas básicas, como la suma, la resta, la multiplicación, la división, la potencia, el módulo, entre otras.</p>
                    <p>Los operadores matemáticos se utilizan para realizar cálculos en expresiones matemáticas en un programa de computadora. En la mayoría de los lenguajes de programación, como Ruby, los operadores matemáticos siguen las mismas reglas que las operaciones matemáticas normales. Por ejemplo, en una expresión matemática 2 + 3 * 4, primero se realizaría la operación de multiplicación (3 * 4) y luego se sumaría el resultado con 2.</p>
                    <p>Los operadores matemáticos son una herramienta fundamental en la programación y se utilizan para realizar todo tipo de cálculos matemáticos. Además de los operadores matemáticos básicos, como la suma, la resta, la multiplicación y la división, los lenguajes de programación modernos también proporcionan operadores matemáticos más avanzados, como la potencia, el módulo, los operadores de comparación, entre otros.</p>
                    <p>En Ruby, los operadores matemáticos básicos son:</p>
                    <p>
                      <ol>
                        <li>Suma (+): se utiliza para sumar dos valores.<br>Ejemplo: 2 + 3</li><br>
                        <li>Resta (-): se utiliza para restar un valor de otro.<br>Ejemplo: 5 - 3</li><br>
                        <li>Multiplicación (*): se utiliza para multiplicar dos valores.<br>Ejemplo: 2 * 3</li><br>
                        <li>División (/): se utiliza para dividir un valor por otro.<br>Ejemplo: 6 / 3</li><br>
                        <li>Módulo (%): devuelve el residuo de una división.<br>Ejemplo: 7 % 3 devuelve 1 (ya que 7 dividido por 3 da un residuo de 1).</li><br>
                        <li>Potencia (**): se utiliza para elevar un valor a una potencia determinada.<br>Ejemplo: 2 ** 3 devuelve 8 (ya que 2 elevado a la potencia de 3 es igual a 8).</li><br>
                      </ol></p>
                    <p>Estos son los operadores matemáticos básicos en Ruby, pero también hay otros operadores matemáticos avanzados, como operadores de comparación, operadores de asignación, operadores bit a bit, etc. que se utilizan en programación.</p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Operadores de comparación</summary>
                    <p>En Ruby, los operadores de comparación se utilizan para comparar dos valores y devolver un valor booleano (verdadero o falso) que indica si la comparación es verdadera o falsa. Los operadores de comparación disponibles en Ruby son:</p>
                    <p>
                      <ul>
                        <li>==  :  Compara si dos valores son iguales.  Ejemplo: 3 == 3 devuelve <b>true</b>.</li>
                        <li>!=  :  Compara si dos valores son diferentes.  Ejemplo: 3 != 4 devuelve <b>true</b>.</li>
                        <li><  :  Compara si un valor es menor que otro.  Ejemplo: 2 < 3 devuelve <b>true</b>.</li>
                        <li>>  :  Compara si un valor es mayor que otro.  Ejemplo: 3 > 2 devuelve <b>true</b>.</li>
                        <li><=  :  Compara si un valor es menor o igual que otro.  Ejemplo: 2 <= 2 devuelve <b>true</b>.</li>
                        <li>>=  :  Compara si un valor es mayor o igual que otro.  Ejemplo: 3 >= 3 devuelve <b>true</b>.</li>
                      </ul>
                    </p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Operadores Lógicos</summary>
                    <p>En Ruby, &&, | |, y ! son operadores lógicos que se utilizan para evaluar expresiones booleanas y producir un resultado booleano. A continuación se describen los conceptos de cada uno de estos operadores:</p>
                    <p>
                      <ul>
                        <li><font color="#FB7B70"><b>&&</b> (AND lógico):</font> Devuelve true si ambas expresiones son verdaderas, de lo contrario devuelve false.<br>
                        Ejemplo: true && false devuelve false, mientras que true && true devuelve true.</li><br>
                        <li><font color="#FB7B70"><b>| |</b> (OR lógico):</font> Devuelve true si al menos una de las expresiones es verdadera, de lo contrario devuelve false.<br>
                        Ejemplo: false | | true devuelve true, mientras que false | | false devuelve false.</li><br>
                        <li><font color="#FB7B70"><b>!</b> (NOT lógico):</font> Devuelve el opuesto booleano de la expresión. Es decir, si la expresión es verdadera, devuelve false, y si la expresión es falsa, devuelve true.<br>
                        Ejemplo: !true devuelve false, mientras que !false devuelve true.</li>
                      </ul>
                    </p>
                    <p>Es importante tener en cuenta que estos operadores se evalúan de izquierda a derecha, y que tienen precedencia según la siguiente jerarquía: <b>!</b> tiene la mayor precedencia, seguido de <b>&&</b>, y finalmente <b>| |</b>. Para cambiar el orden de evaluación, se pueden utilizar paréntesis.</p>
                </details>
                <p> </p>
                <details>
                  <summary class="sumary">Control Flow</summary>
                    <p>La estructura de control de flujo se utiliza para controlar el flujo de ejecución del programa. Algunos ejemplos de estructuras de control de flujo en Ruby incluyen:</p>
                    <p>
                      <ul>
                        <h3>Condicionales</h3>
                        <li><b><font color="#FB7B70">if</font></b> (si): Se utiliza para ejecutar un bloque de código si una condición es verdadera.</li>
                        <li><b><font color="#FB7B70">elsif</font></b> (si no, si): Se utiliza junto con if para evaluar una condición adicional si la primera condición es falsa.</li>
                        <li><b><font color="#FB7B70">else</font></b> (si no): Se utiliza junto con if y elsif para ejecutar un bloque de código si ninguna de las condiciones anteriores es verdadera.</li>
                        <li><b><font color="#FB7B70">unless</font></b> (a menos que): Se utiliza para ejecutar un bloque de código si una condición es falsa.</li>
                        <h3>Bucles</h3>
                        <li><b><font color="#FB7B70">while</font></b> (mientras): Se utiliza para ejecutar un bloque de código mientras una condición sea verdadera.</li>
                        <li><b><font color="#FB7B70">until</font></b> (hasta que): Se utiliza para ejecutar un bloque de código hasta que una condición sea verdadera.</li>
                        <li><b><font color="#FB7B70">for</font></b> (para): Se utiliza para iterar sobre una colección de objetos.</li>
                        <li><b><font color="#FB7B70">in</font></b> (en): Se utiliza junto con for para especificar la colección de objetos a iterar.</li>
                        <li><b><font color="#FB7B70">times</font></b> (veces): Se utiliza para ejecutar un bloque de código un número específico de veces..</li>
                        <h3>Estructura</h3>
                        <li><b><font color="#FB7B70">case</font></b> (caso): Se utiliza para evaluar una expresión en diferentes casos y ejecutar un bloque de código correspondiente.</li>
                        <li><b><font color="#FB7B70">when</font></b> (cuando): Se utiliza junto con case para especificar una condición a evaluar.</li>
                        <h3>Control de Bucles</h3>
                        <li><b><font color="#FB7B70">next</font></b> (siguiente): Se utiliza para saltar a la siguiente iteración de un bucle (while, until, for).</li>
                        <li><b><font color="#FB7B70">break</font></b> (romper): Se utiliza para salir de un bucle (while, until, for).</li>
                        <li><b><font color="#FB7B70">redo</font></b> (repetir): Se utiliza para repetir la iteración actual en un bucle (while, until, for) desde el principio.</li>
                        <li><b><font color="#FB7B70">retry</font></b> (reintentar): Se utiliza para volver a intentar ejecutar un bloque de código desde el principio, generalmente después de haber capturado una excepción.</li>
                      </ul>
                    </p>
                    <p>En conclusión, Ruby ofrece una variedad de estructuras de control de flujo que permiten a los desarrolladores escribir programas más complejos y poderosos. La mayoría de las estructuras de control de flujo en Ruby tienen una sintaxis clara y fácil de entender.</p>
                    <p>Es importante tener en cuenta que un uso excesivo de estructuras de control de flujo puede dificultar la lectura y el mantenimiento del código. Por lo tanto, es recomendable utilizar estructuras de control de flujo de manera efectiva y en combinación con otras técnicas de programación para escribir código claro y fácil de entender.</p>
                    <p>Además, Ruby también ofrece varias instrucciones de control de bucles que permiten a los desarrolladores tener un mayor control sobre la ejecución de los bucles y la iteración. La comprensión y el uso efectivo de estas instrucciones son esenciales para escribir código eficiente y funcional.</p>
                     <hr> 
                    <p><b><font color="#FB7B70">1. if elsif else</font></b> es muy común en Ruby para controlar diferentes casos que pueden ocurrir dentro de una estructura condicional.</p>
                      <img src="img/ruby/rub_control_flow.jpg" alt="control_flow" width="700px">
                       <hr> 
                    <p><b><font color="#FB7B70">2. unless</font></b> es una estructura de control de flujo que se utiliza para ejecutar una sección de código solo si una condición no se cumple. En otras palabras, unless es el opuesto de if.</p>
                      <code>
                        <p>edad = <font color="#FB7B70">20</font><br><br>
                        unless edad >= <font color="#FB7B70">18</font><br>
                        puts <font color="#89C363">"Eres menor de edad"</font><br>
                        <font color="#3E95DB">else</font><br>
                        puts <font color="#89C363">"Eres mayor de edad"</font><br>
                        end</p>
                      </code>
                    <p>En este ejemplo, la estructura unless se utiliza para evaluar si la variable edad es menor que 18. Si la edad es menor que 18, se imprime "Eres menor de edad". Si la edad es mayor o igual a 18, se imprime "Eres mayor de edad".</p>
                    <p>En resumen, unless es una estructura de control de flujo útil para ejecutar una sección de código solo si una condición no se cumple.</p>
                     <hr> 
                    <p><b><font color="#FB7B70">3. do</font></b> se utiliza para indicar el inicio del bloque de código que se ejecutará para cada elemento de la colección, y end se utiliza para indicar el final del bloque de código. </p>
                    <p>El siguiente es un ejemplo simple de cómo usar do con el método each para iterar sobre una matriz e imprimir cada elemento:</p>
                      <code>
                        <p>nombres = <font color="#FB7B70">["Ana", "María", "Juan"]</font><br><br>
                        nombres.each <font color="#3E95DB">do</font> |nombre|<br>
                        puts <font color="#89C363">"El nombre es #{nombre}"</font><br>
                        <font color="#3E95DB">end</font></p>
                      </code>
                    <p>En este ejemplo, la variable nombres contiene una matriz de tres nombres. El método each se utiliza para iterar sobre cada elemento de la matriz. La estructura do se utiliza para delimitar el bloque de código que se ejecutará junto con cada elemento del array. En este caso, el bloque de código contiene una única línea que imprime el nombre actual en la matriz.</p>
                    <p>El resultado de este código sería:</p>
                    <p>
                      <code>El nombre es Ana<br>
                      El nombre es María<br>
                      El nombre es Juan
                      </code>
                    </p>
                    <p>Es importante tener en cuenta que en Ruby, los bloques pueden delimitarse de varias formas diferentes, como do y end o { y }. En general, se recomienda usar <b>do</b> y <b>end</b> para bloques de varias líneas y <b>{ }</b> para bloques de una sola línea.</p>
                     <hr> 
                    <p><b><font color="#FB7B70">4. while</font></b> es una estructura de control de flujo útil en Ruby que permite ejecutar un bloque de código repetidamente mientras se cumple una condición específica. Sin embargo, es importante utilizarla con cuidado para evitar ciclos infinitos.</p>
                    <p><img src="img/ruby/rub_loop_while.jpg" alt="ruby_while" width="700px"></p>
                    <p>Mientras la condición sea verdadera, el bloque de código se ejecutará una y otra vez. Cuando la condición se vuelve falsa, el programa saldrá del ciclo y continuará con el resto del código.</p>
                    <p>Es importante tener en cuenta que la condición de while debe actualizarse adecuadamente dentro del bloque de código para evitar que el ciclo se ejecute infinitamente. Si la condición no cambia nunca, el programa se quedará atrapado en un ciclo infinito.</p>
                     <hr> 
                    <p><b><font color="#FB7B70">5. until</font></b> es una estructura de control de flujo útil en Ruby que permite ejecutar un bloque de código repetidamente hasta que se cumpla una condición específica. Esta estructura se utiliza principalmente cuando se quiere evaluar una condición en términos negativos.</p>
                    <p>A diferencia de la estructura while, que se ejecuta mientras una condición es verdadera, la estructura until se ejecuta mientras una condición es falsa. Ambas estructuras son similares y se utilizan para controlar el flujo de un programa, pero until se puede utilizar cuando la condición que se quiere evaluar es más natural expresarla en términos negativos.</p>
                    <p><img src="img/ruby/rub_loop_until.jpg" alt="ruby_until"></p>
                     <hr> 
                    <p><b><font color="#FB7B70">6. for</font></b> es una estructura de control de flujo en Ruby que permite iterar sobre una colección de elementos, como un arreglo o un rango de números. Aunque no es tan común como otras estructuras como each y map, sigue siendo una opción válida y útil en algunos casos.</p>
                    <p><img src="img/ruby/rub_loop_for.jpg" alt="ruby_for"></p>
                    <p>Es importante tener en cuenta que en Ruby, es más común utilizar otras estructuras de control de flujo como each y map para iterar sobre colecciones de elementos, ya que son más flexibles y poderosas que la estructura for. Sin embargo, for sigue siendo una opción válida y útil en algunos casos.</p>
                     <hr> 
                    <p><b><font color="#FB7B70">6. case when</font></b> son palabras clave en el lenguaje de programación Ruby que se utilizan para realizar una serie de comprobaciones de igualdad en una expresión dada.</p>
                    <p>Por ejemplo, el siguiente código en Ruby utiliza case y when para determinar si un número es positivo, negativo o cero:</p>
                    <p><img src="img/ruby/rub_loop_case.jpg" alt="ruby_case"></p>
                    <p>En este ejemplo, el valor de num es -5, lo que significa que la condición en el último when se cumple y se ejecuta la línea puts "El número es negativo".</p>
                     <hr> 
                    <p><b><font color="#FB7B70">7. times</font></b> es un método de Ruby que se utiliza para ejecutar un bloque de código un número específico de veces. Se utiliza comúnmente para ejecutar un bloque de código un número fijo de veces, por ejemplo, para imprimir una línea de texto varias veces.</p>
                    <p>La sintaxis básica de .times es la siguiente:</p>
                    <p><font color="#FB7B70">5.</font>times <font color="#3E95DB">do</font><br>
                    puts <font color="#89C363">"I am learning in codeable!"</font><br>
                    <font color="#3E95DB">end</font></p>
                    <p>En este ejemplo, el bloque de código se ejecutará 5 veces y en cada iteración imprimirá "I am learning in codeable!". El resultado sería:</p>
                    <p>
                      <code>
                        I am learning in codeable!<br>
                        I am learning in codeable!<br>
                        I am learning in codeable!<br>
                        I am learning in codeable!<br>
                        I am learning in codeable!<br>
                      </code>
                    </p>
                </details>
            </details>
            <p><font color="#90A4AE">Resumen, Datos (Concepto, Tipos), Imprimir (puts y print), Concatenar/Interpolar, Comentar en el código, Operadores Matemáticos, Operadores de comparación, Operadores Lógicos, Control Flow.</font></p>
            <p> </p>
            <details>
              <summary class="sub">Ruby Basic 2</summary>
                <p> </p>
                <details>
                  <p><summary class="sumary">Arrays</summary></p>
                  <p><h3>Concepto</h3></p>
                  <p>Un array es una colección ordenada de elementos del mismo tipo de datos, que se pueden acceder y manipular a través de un índice numérico. Los arrays en Ruby pueden contener cualquier tipo de objeto, incluyendo otros arrays.</p>
                  <p>Los arrays en Ruby se definen utilizando corchetes [ ] y separando los elementos por comas.</p>
                  <p><img src="img/ruby/rub_arrays.jpg" alt="Ruby Arrays"></p>
                  <p>Además, Ruby proporciona varios métodos útiles para trabajar con arrays, como por ejemplo:</p>
                  <p>
                    <ul>
                      <li><b>length o size:</b> para obtener el número de elementos de un array.</li>
                      <li><b>join:</b> para unir los elementos de un array en una cadena de texto.</li>
                      <li><b>sort:</b> para ordenar los elementos de un array.</li>
                      <li><b>reverse:</b> para invertir el orden de los elementos en un array.</li>
                    </ul>
                  </p>
                  <p><img src="img/ruby/rub_arrays2.jpg" alt="Ruby Arrays"></p>
                  <p><h3>Indice de un array</h3></p>
                  <p>Cada elemento dentro de un array se identifica mediante un índice numérico que comienza en cero y se incrementa en uno para cada elemento adicional.</p>
                  <p>Podemos acceder a un elemento específico en el array utilizando su índice. El primer elemento del array tiene un índice de 0, el segundo tiene un índice de 1, y así sucesivamente. Por lo tanto, para acceder al primer elemento del array (1), utilizamos el índice 0:</p>
                  <p><img src="img/ruby/rub_arraysindex.jpg" alt="arrays index"></p>
                  <p><h3>Nested Arrays (Arreglo dentro de un arreglo)</h3></p>
                  <p>Los nested arrays (arrays dentro de arrays) son una estructura de datos que permiten almacenar una colección de elementos, donde uno o más de los elementos son a su vez arrays.</p>
                  <p>En otras palabras, un nested array es un array que contiene otros arrays como elementos. Esto permite representar estructuras de datos más complejas, como matrices, tablas, y listas de listas.</p>
                  <p><img src="img/ruby/rub_arraysnested.jpg" alt="arrays nested"></p>
                  <p><h3>Arrays Operators (Operadores de arreglos)</h3></p>
                  <p>Los operadores de arrays en Ruby son un conjunto de métodos y símbolos que se utilizan para realizar operaciones comunes en arrays. Estos operadores son una parte importante del lenguaje Ruby, ya que permiten manipular y transformar arrays de manera eficiente y legible.</p>
                  <p>Los operadores de arrays más comunes en Ruby incluyen:</p>
                  <p><b><font color="#FB7B70">+ :</font></b> Este operador se utiliza para concatenar dos arrays.</p>
                  <p><img src="img/ruby/rub_arrays_concat.jpg" alt="array concat"></p>
                  <p> </p>
                  <p><b><font color="#FB7B70">- :</font></b> Este operador se utiliza para eliminar los elementos de un array que también aparecen en otro array. (todos los elementos del segundo array -el que viene a restar- mas los elementos del primer array -al que se le resta- que se repitan en el segundo)</p>
                  <p><img src="img/ruby/rub_arrays_resta.jpg" alt="array resta"></p>
                  <p> </p>
                  <p><b><font color="#FB7B70">& :</font></b> El operador de intersección devuelve un nuevo array que contiene sólo los elementos que están presentes en ambos arrays.</p>
                  <p><img src="img/ruby/rub_arrays_intersec.jpg" alt="array intersección"></p>
                  <p> </p>
                  <p><b><font color="#FB7B70">| :</font></b> El operador de unión devuelve un nuevo array que contiene todos los elementos de ambos arrays, sin duplicados.</p>
                  <p><img src="img/ruby/rub_arrays_union.jpg" alt="array union"></p>
                  <p><i>También es posible utilizar los métodos intersection y union para realizar estas operaciones.</i></p>
                  <p><img src="img/ruby/rub_arrays_interuni.jpg" alt="array intersec"></p>
                  <p> </p>
                  <p><b><font color="#FB7B70">* :</font></b> Este operador se utiliza para repetir un array un número determinado de veces.</p>
                  <p><img src="img/ruby/rub_arrays_multiply.jpg" alt="array multi"></p>
                  <p> </p>
                  <p><b><font color="#FB7B70">[ ] :</font></b> Este operador se utiliza para acceder a un elemento específico de un array mediante su índice. También se puede utilizar para acceder a un rango de elementos.</p>
                  <p><img src="img/ruby/rub_arrays_corchete.jpg" alt="array corchete"></p>
                  <p> </p>
                  <p><h3>Arrays Methods (Metódos en un arreglo)</h3></p>
                  <p>En Ruby, los arrays tienen una amplia variedad de métodos disponibles para manipularlos y acceder a ellos. Algunos de los métodos más comunes son:</p>
                  <p><b><font color="#FB7B70">at : </font></b> Este método se utiliza para acceder a un elemento específico de un array mediante su índice. Es equivalente a utilizar el operador [ ].</p>
                  <p><img src="img/ruby/rub_arrays_meth_at.jpg" alt="array method at"></p>
                  <p><b><font color="#FB7B70">push : </font></b> Este método se utiliza para agregar un elemento al final de un array.</p>
                  <p><img src="img/ruby/rub_arrays_meth_push.jpg" alt="array method push"></p>
                  <p><b><font color="#FB7B70">shift : </font></b> Este método se utiliza para eliminar el primer elemento de un array y devolverlo.</p>
                  <p><img src="img/ruby/rub_arrays_meth_shift.jpg" alt="array method shift"></p>
                  <p><b><font color="#FB7B70">length o size : </font></b> Estos métodos se utilizan para obtener el tamaño de un array.</p>
                  <p><img src="img/ruby/rub_arrays_meth_size.jpg" alt="array method size"></p>
                  <p><b><font color="#FB7B70">sort : </font></b> Este método se utiliza para ordenar los elementos de un array.</p>
                  <p><img src="img/ruby/rub_arrays_meth_sort.jpg" alt="array method sort"></p>
                  <p><b><font color="#FB7B70">reverse : </font></b> Este método se utiliza para invertir el orden de los elementos de un array.</p>
                  <p><img src="img/ruby/rub_arrays_meth_reverse.jpg" alt="array method reverse"></p>
                  <p><b><font color="#FB7B70">compact : </font></b> Este método se utiliza para eliminar los elementos nulos de un array.</p>
                  <p><img src="img/ruby/rub_arrays_meth_compact.jpg" alt="array method compact"></p>
                  <p><b><font color="#FB7B70">map o collect : </font></b>: Estos métodos se utilizan para transformar los elementos de un array mediante una función.</p>
                  <p><img src="img/ruby/rub_arrays_meth_map.jpg" alt="array method map"></p>
                  <p><b><font color="#FB7B70">each : </font></b> Este método se utiliza para iterar sobre los elementos de un array.</p>
                  <p><img src="img/ruby/rub_arrays_meth_each.jpg" alt="array method each"></p>
                  <p><font color="#23D959">NOTA: each y map hacen los mismo a diferencia que each solo opera dentro del arreglo y fuera de él no se conserva su nuevos valores, en cambio maps puede asignar el valor a una nueva variable y usarse fuera del arreglo.</font></p>
                  <p> </p>
                  <p><b><font color="#FB7B70">each_with_index : </font></b> Se utiliza para iterar sobre un array y al mismo tiempo acceder al índice de cada elemento. Este método toma un bloque que recibe dos argumentos: el primer argumento es el valor del elemento y el segundo argumento es el índice del elemento.</p>
                  <p><img src="img/ruby/rub_arrays_meth_eachindex.jpg" alt="array method with index"></p>
                  <p>Estos son solo algunos de los métodos disponibles para los arrays en Ruby. Hay muchos más que puedes explorar en la documentación oficial de Ruby.</p>                  
                </details>
                <p> </p>               
                <details>
                  <p><summary class="sumary">Hashes</summary></p>
                  <p><h3>Concepto</h3></p>
                  <p>Un hash es una colección de pares <b><font color="#FB7B70">key-value</font></b>, donde cada <b><font color="#FB7B70">key</font></b> está asociada a un <b><font color="#FB7B70">value</font></b> único. Los hashes se definen utilizando llaves <b><font color="#FB7B70">{ }</font></b> y los pares <b><font color="#FB7B70">key-value</font></b> se separan por comas.</p>
                  <p><img src="img/ruby/rub_hash.jpg" alt="ruby hash"></p>
                  <p>Las keys pueden ser cualquier objeto de Ruby, pero generalmente se utilizan símbolos o cadenas de texto. Los valores también pueden ser cualquier objeto de Ruby, incluyendo otros hashes.</p>
                  <p><img src="img/ruby/rub_hash2.jpg" alt="ruby hashes"></p>
                  <p> </p>
                  <p><h3>Symbol</h3></p>
                  <p>los símbolos son objetos inmutables que se utilizan como identificadores únicos en el programa. Los símbolos se definen anteponiendo los dos puntos <b>( : )</b> al nombre del símbolo.</p>
                  <p><img src="img/ruby/rub_symbol.jpg" alt="ruby symbol"></p>
                  <p>Los símbolos son útiles porque ocupan menos memoria que las cadenas de texto, y porque son más eficientes para comparar y buscar en el programa.</p>
                  <p>Dentro de un hash el símbolo se utiliza como key y se convierte automáticamente en un símbolo.</p>
                  <p><img src="img/ruby/rub_symbol2.jpg" alt="ruby symbol"></p>
                  <p>En este caso, <b>nombre:</b> es un símbolo que se utiliza como key en el hash, y "Juan" es el value asociado a la key.</p>
                  <p> </p>
                  <p><h3>Methods in Hashes</h3></p>
                  <p>En Ruby, un método es una pieza de código que realiza una tarea específica y se puede llamar en cualquier parte del programa. </p>                
                  <p>Algunos ejemplos de metodos:</p>
                  <p><img src="img/ruby/rub_hash.metods.jpg" alt="ruby metodos"></p>
                  <p><h3>MAP in Hashes</h3></p>
                  <p>En Ruby, el método .map se puede utilizar en una hash para transformar los values de un hash, pero no las keys. El método .map <b>devuelve un array</b> con los resultados de la operación realizada en cada valor del hash.</p>
                  <p><img src="img/ruby/rub_hash_map.jpg" alt="map in hash"></p>
                </details>
            </details>
            <p><font color="#90A4AE">Arrays : Concepto, Indice de un array, Nested Arrays, Arrays Operators, Arrays Methods.<br>
            Hashes : Concepto, Symbol, Methods in Hashes, MAP in Hashes.</font></p>
            <p> </p>
            <!-- <details> -->
              <summary class="sub">Ruby Methods</summary>
                <p> </p>
                <details>
                  <p><summary class="sumary">Concepto</summary></p>
                  <p>En Ruby, un método es una pieza de código que se puede llamar o invocar para realizar una tarea específica. Los métodos son definidos dentro de clases o módulos, y pueden ser públicos, privados o protegidos, lo que afecta su visibilidad y accesibilidad.</p>
                  <p>Para definir un método en Ruby, se utiliza la palabra clave def seguida del nombre del método y sus argumentos entre paréntesis (si los tiene). Luego, el cuerpo del método se escribe entre las palabras clave def y end.</p>
                  <p><img src="img/ruby/rub_metod.jpg" alt="ruby metodo"></p>
                  <p><h3>Invoque Methods (llamando al método)</h3></p>
                  <p>Para invocar o llamar a un método lo hacemos con el <b>nombre del método</b> seguido de unos parentesis donde debemos indicar un argumento para el parámetro, (entiéndase como asignarle un valor a una variable)</p>
                  <p><img src="img/ruby/rub_metod_invoc.jpg" alt="ruby invocar"></p>
                </details>
                <p> </p>
                <details>
                  <p><summary class="sumary">Return Explicit and Implicit</summary></p>
                  <p>En Ruby, hay dos formas diferentes en las que los métodos pueden devolver valores: "Return Explicit" y "Return Implicit".</p>
                  <p><b>Explicit Return : </b> se refiere a cuando se utiliza la palabra clave "return" para indicar que una función o método debe devolver un valor específico.</p>
                  <p><img src="img/ruby/rub_metod_ret_expl.jpg" alt="retorno explicito"></p>
                  <p><b>Implicit return : </b> se produce cuando la última línea de una función o método es una expresión que se evalúa como el valor de retorno.</p>
                  <p><img src="img/ruby/rub_metod_ret_impl.jpg" alt=""></p>
                  <p>Es importante tener en cuenta que la mayoría de las veces en Ruby se utiliza el retorno implícito, ya que es más conciso y hace que el código sea más fácil de leer. Sin embargo, en ciertas situaciones, puede ser necesario utilizar el retorno explícito para devolver un valor específico.</p>
                </details>
                <p> </p>
                <details>
                  <p><summary class="sumary">Default Arguments</summary></p>
                  <p>Los "default arguments" son valores predeterminados que se pueden asignar a los parámetros de un método. Esto significa que si no se proporciona un argumento al invocar al método, se usará el valor predeterminado.</p>
                  <p><img src="img/ruby/rub_metod_defa_arg.jpg" alt="Default Argument"></p>
                  <p>En este caso, el segundo parametro tiene un valor predeterminado, mientras que el primer y tercer parametro son obligatorios. Si se invoca al método con dos argumentos, el segundo parametro conserva el valor predeterminado como argumento y el tercer parametro recibirá el segundo argumento que se proporciona.</p>
                </details>
                <p> </p>
                <details>
                  <p><summary class="sumary">Truthy y Falsy</summary></p>
                  <p>En Ruby, un valor "truthy" se refiere a cualquier valor que se evalúa como verdadero en un contexto booleano. Por otro lado, un valor "falsy" se refiere a cualquier valor que se evalúa como falso en un contexto booleano.</p>
                  <p>En general, los siguientes valores se consideran Truthy en Ruby:</p>
                  <p><ul>
                    <li>Cualquier valor numérico diferente de cero (por ejemplo, 1, 3.14, -5).</li>
                    <li>Cualquier cadena de caracteres no vacía (por ejemplo, "hola", "Ruby").</li>
                    <li>Cualquier objeto (por ejemplo, una instancia de una clase personalizada).</li>
                    <li>Cualquier arreglo, hash o estructura de datos que no esté vacía.</li>
                    <li>El valor booleano true.</li>
                  </ul></p>
                  <p>Por otro lado, los siguientes valores se consideran Falsy en Ruby:</p>
                  <p><ul>
                    <li>El valor booleano false.</li>
                    <li>El valor nulo (nil).</li>
                    <li>El número cero (0).</li>
                    <li>Una cadena de caracteres vacía ("").</li>
                    <li>Un arreglo, hash o estructura de datos vacía.</li>
                  </ul></p>
                  <p>Es importante tener en cuenta que el concepto de Truthy y Falsy en Ruby es específico del contexto booleano. En otros contextos, estos mismos valores pueden tener un comportamiento diferente. Por ejemplo, el número cero puede ser válido en un contexto numérico, pero se evalúa como Falsy en un contexto booleano.</p>
                </details>
                <p> </p>
                <details>
                  <p><summary class="sumary">Keywords Arguments</summary></p>
                  <p>En Ruby, los argumentos de palabras clave (o "keyword arguments" en inglés) son una característica que permite pasar argumentos a un método mediante la especificación de sus nombres explícitamente.</p>
                  <p>Por defecto, los argumentos de un método en Ruby se pasan por orden de posición, lo que significa que el primer argumento que se especifica se asigna al primer parámetro del método, el segundo argumento se asigna al segundo parámetro, y así sucesivamente. Sin embargo, cuando se utilizan argumentos de palabras clave, el orden de los argumentos ya no importa, ya que se especifican explícitamente los nombres de los parámetros que se están pasando.</p>
                  <p>Para definir un método con argumentos de palabras clave, se utiliza el símbolo <b><font color="#FB7B70">:</font></b> antes del nombre del parámetro en la lista de argumentos.</p>
                  <p><img src="img/ruby/rub_metod_keyw_arg.jpg" alt="keyword argument"></p>  
                  <p>En este ejemplo, el método saludar toma dos argumentos de palabras clave: <b>nombre:</b> y <b>mensaje:</b>. Cuando se llama a este método, se debe especificar el nombre de cada argumento junto con su valor. De esta manera, el orden de los argumentos ya no importa, y es más fácil entender qué valor se está pasando a cada parámetro. Los argumentos de palabras clave también pueden tener valores predeterminados, lo que permite omitirlos al llamar al método y usar su valor por defecto.</p>
                  <p><img src="img/ruby/rub_metod_keyw_arg2.jpg" alt="keyword arguments"></p>
                  <p>En este ejemplo, el argumento mensaje tiene un valor predeterminado de "Hola", por lo que se puede llamar al método sin especificar este argumento: <b>Esto imprimirá "Hola, Juan!"</b>.</p>
                </details>
                <p> </p>
                <details>
                  <p><summary class="sumary">Splat Operator</summary></p>
                  <p>El Splat Operator se representa por el símbolo <b>*</b> y se utiliza para indicar que un parámetro puede recibir cierta cantidad de argumentos, que serán <b><font color="#FB7B70">tratados como un arreglo</font></b> dentro del método.</p>
                  <p>Cuando se utiliza el Splat Operator en el contexto de los parámetros de un método, puede aparecer tanto al inicio como al final de la lista de parámetros, aunque es más común encontrarlo al final. Si se utiliza al inicio, indica que el método espera al menos un argumento, y los demás argumentos opcionales pueden ser proporcionados como un arreglo. Si se utiliza al final, indica que el método espera cualquier cantidad de argumentos, y que éstos serán capturados en un solo arreglo.</p>
                  <p><img src="img/ruby/rub_metod_splat_oper.png" alt="Splat operator"></p>
                  <p>En este ejemplo, el Splat Operator indica que el método <b>sum</b> puede recibir cualquier cantidad de argumentos, que serán tratados como un <b>array</b> llamado numbers dentro del método <b>sum</b>. Luego, se utiliza un ciclo <b>each</b> para sumar los números del arreglo y devolver el resultado.</p>
                  <p></p>
                </details>
                <p> </p>
                <!-- <details> -->
                  <p><summary class="sumary">Double Splat Operator</summary></p>
                  <p>En Ruby, el Double Splat Operator (**), también conocido como "hash rocket", permite a los parametros recibir argumentos del tipo Keywords Arguments los cuales serán <b><font color="#FB7B70">tratados como un hash.</font></b> El Double Splat Operator convierte estos Keywords Arguments en un hash con sus keys y values correspondientes.</p>
                  <p></p>
                  <p></p>
                  <p></p>
                  <p></p>
                  <p></p>
                  <p></p>
                  <p></p>
                  <p></p>
                  <p></p>
                <!-- </details> -->
                <p> </p>
            <!-- </details> -->
            <p><font color="#90A4AE">Concepto, Retorno Implicito y Explicito, Default Arguments, Truthy y Falsy, Keywords Arguments, Splat Operator, Double Splat Operator.</font></p>
            <p> </p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>                
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                <p></p>
                


            
          
          
        </div>        
      </section>
    </main>
    <footer>
        <center>
            <p class="fut" align="center">Sponsored by:</p><BR>
            <img class="fut" src="img/foot/bcp.png" alt="bcp">
            <img class="fut" src="img/foot/ca.png" alt="codeable">
            <img class="fut" src="img/foot/na.png" alt="nasa">
            <img class="fut" src="img/foot/nx.png" alt="netflix">
            <img class="fut" src="img/foot/ms.png" alt="microsoft">
        </center>
    </footer>
  </body>
</html>
